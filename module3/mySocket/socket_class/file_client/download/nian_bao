#1：不管是recv还是send都不是直接接收对方的数据，而是操作自己的操作系统内存--->不是一个send对应一个recv
#2：recv：
        wait data 等待操作系统从网卡拿到属于应用程序端口的数据，耗时非常长
        copy data 从操作系统内存拷贝数据到应用内存
    send：
        copy data 从应用内存拷贝数据到操作系统内存
        send data 操作系统调传输层/网络层/数据链路层，对数据进行TCP/IP/ethernet的包装，再由网络层，发送高低压信号。

粘包：
客户端粘包：
原因是TCP的优化算法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。
这就导致了可能存在将多个包合成一个包发给服务端，服务端一次就接受完了，然后无法将包拆成三个包，数据就乱了。
服务端粘包：
原因是，在收包的时候，每次是拿固定长度的数据，比如1024，当包的大小大于1024时，收一次并不能收完，剩下的数据还在操作系统内存里。
当下一次客户端再发包时，到服务端时就和之前的数据粘在一起了，服务端再来接收数据的时候，根本无法拆开数据。

杠精可能会说在接收数据的时候，服务端每次接收10000000024个字节，不就没有粘包了么
1.计算机的内存有限，收数据的实质是从操作系统软件的内存拷贝到应用软件的内存，收的数据过大直接撑爆内存
2.每次发送数据的大小不可预知，谁可以肯定不存在几个G的视频？所以定义的每次接收数据再大也有可能不够大的情况

解决粘包：
发数据分三个步骤
1.发送固定长度的 报头描述(内容为：记录报头的长度)
2.发送 报头 (内容为：记录此次发送的数据的属性，比如数据名，大小，报头格式为字典，可以用json转)
3.发送 数据 (内容为本次要发送的数据)

接收数据也分为三个步骤：
1.接收4个字节，拿到报头的长度
2.根据上面的报头长度，接收这个长度的数据，就是报头了，解析报头的数据拿到此次数据的长度
3.根据上面的数据长度，循环接收数据，直到接收到的数据长度等于报头里描述的数据长度才停止本次接收